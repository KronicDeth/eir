
struct MatchNode {
    kind: MatchNodeKind,
}
enum MatchNodeKind {
    Fail,
    Leaf(usize),
}

#[derive(Debug)]
enum Test {
    Type,
}

#[derive(Debug)]
enum TypeBranch {
    ListCell(Test, Test),
    Tuple(Vec<Test>),
    Nil,
    Integer,
    Atom(u32),
}

#[derive(Debug)]
struct MatchMatrix {
    variables: usize,
    clauses: usize,
    matrix: Vec<MatchMatrixElement>,
}
#[derive(Debug)]
struct MatchMatrixElement {
    variable_num: usize,
    clause_num: usize,
    pattern: PatternNode,
    edge: MatchEdge,
}

impl MatchMatrix {

    fn new(arms: Vec<MatchMatrixElement>, variables: usize, clauses: usize) -> Self {
        MatchMatrix {
            variables: variables,
            clauses: clauses,
            matrix: arms,
        }
    }

    fn clauses_iter<'a>(&'a self) -> Chunks<MatchMatrixElement> {
        self.matrix.chunks(self.variables)
    }
    fn clauses_iter_mut<'a>(&'a mut self) -> ChunksMut<MatchMatrixElement> {
        self.matrix.chunks_mut(self.variables)
    }

    fn specialize(&self) -> Specializations {
        let match_edges: Vec<_> = self.matrix.iter()
            .map(|m| get_match_edge(&m.pattern))
            .collect();

        let mut var_scores = vec![0u32; self.variables];
        for clause in match_edges.chunks(self.variables) {
            for (idx, var) in clause.iter().enumerate() {
                if var != &MatchEdge::Wildcard {
                    var_scores[idx] += 1;
                }
            }
        }

        let spec_variable_num = var_scores.iter().enumerate()
            .max_by_key(|&(_idx, score)| score)
            .map(|(idx, _score)| idx)
            .unwrap();
        println!("spec variable num: {}", spec_variable_num);

        let mut specializations = match_edges.chunks(self.variables)
            .map(|e| *e.iter().nth(spec_variable_num).unwrap())
            .collect::<HashSet<MatchEdge>>();
        let has_wildcard = specializations.contains(&MatchEdge::Wildcard);
        specializations.remove(&MatchEdge::Wildcard);

        for specialization in specializations.iter() {
            self.specialize_on(spec_variable_num, *specialization);
        }

        unimplemented!()
    }

    fn specialize_on(&self, variable: usize,
                     edge: MatchEdge) -> MatchMatrix {
        println!("specialize on: {:?}", edge);

        self.clauses_iter()
            .filter(|clause| {
                clause[variable].edge == edge
                    || clause[variable].edge == MatchEdge::Wildcard
            })
            .flat_map(|clause| {
                clause.iter()
                    .flat_map(|pat| {
                        if pat.variable_num == variable {
                            specialize_match(pat, &edge)
                        } else {
                            vec![pat.pattern.clone()]
                        }
                    })
            });

        unimplemented!()
    }

    fn specialize_default(&self, variable: usize,
                          edges: HashSet<MatchEdge>) -> MatchMatrix {
        unimplemented!()
    }

}

#[derive(Debug)]
struct Specializations {
    nodes: Vec<(PatternNode, MatchMatrix)>,
    default: MatchMatrix,
}

fn specialize_match(pat: &MatchMatrixElement, mat: &MatchEdge) -> Vec<PatternNode> {
    let pat_edge = get_match_edge(pat);
    if mat == &pat_edge {
        vec![]
    } else {
        unimplemented!()
    }
}

fn get_match_edge(node: &PatternNode) -> MatchEdge {
    match *node {
        PatternNode::List(ref head, ref tail) => {
            if head.len() >= 1 {
                MatchEdge::ListCell
            } else {
                get_match_edge(tail)
            }
        },
        PatternNode::Atomic(AtomicLiteral::Nil) => MatchEdge::Nil,
        PatternNode::Variable(_) => MatchEdge::Wildcard,
        PatternNode::Bind(_, _) => MatchEdge::Wildcard,
        _ => panic!(),
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
enum MatchEdge {
    ListCell,
    Nil,
    Wildcard,
}
impl MatchEdge {

    fn arity(&self) -> usize {
        match *self {
            MatchEdge::ListCell => 2,
            MatchEdge::Nil => 0,
            MatchEdge::Wildcard => unreachable!(),
        }
    }

}

pub fn to_decision_tree(clauses: &Vec<Vec<PatternNode>>) {

    let mut context = MatchCompileContext::new(clauses);

    let clauses_len = clauses.len();
    let pattern_len = clauses[0].len();
    if clauses_len == 0 {
        panic!()
    }

    let mut matrix_list = Vec::new();
    for (clause_idx, clause) in clauses.iter().enumerate() {
        assert!(clause.len() == pattern_len);
        for (pattern_idx, pattern) in clause.iter().enumerate() {
            matrix_list.push(MatchMatrixElement {
                clause_num: clause_idx,
                variable_num: pattern_idx,
                pattern: pattern.clone(),
                edge: get_match_edge(pattern),
            });
        }
    }
    let matrix = MatchMatrix::new(matrix_list, pattern_len, clauses.len());
    println!("{:#?}", matrix);

    let specialized = matrix.specialize();
    println!("{:#?}", specialized);
}